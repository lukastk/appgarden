# AUTOGENERATED! DO NOT EDIT! File to edit: pts/tests/test_remote.pct.py

__all__ = ['test_check_privileged_helper_installed', 'test_check_privileged_helper_missing', 'test_garden_state_roundtrip', 'test_garden_state_with_ctx', 'test_make_remote_context_custom_app_root', 'test_make_remote_context_nonroot', 'test_make_remote_context_root', 'test_path_functions_custom_root', 'test_path_functions_default', 'test_ports_state_roundtrip', 'test_privileged_install_unit_nonroot', 'test_privileged_install_unit_root', 'test_privileged_journalctl_nonroot', 'test_privileged_journalctl_root', 'test_privileged_remove_unit_nonroot', 'test_privileged_remove_unit_root', 'test_privileged_systemctl_nonroot_caddy_reload', 'test_privileged_systemctl_nonroot_daemon_reload', 'test_privileged_systemctl_nonroot_no_wrapper', 'test_privileged_systemctl_nonroot_wrapper', 'test_privileged_systemctl_root_no_ctx', 'test_privileged_systemctl_root_passthrough', 'test_read_remote_file', 'test_read_remote_file_failure', 'test_remote_context_defaults', 'test_run_remote_command', 'test_run_remote_command_failure', 'test_run_sudo_command_no_ctx', 'test_run_sudo_command_no_sudo', 'test_run_sudo_command_with_chain', 'test_run_sudo_command_with_sudo', 'test_upload_directory_exclude_and_gitignore', 'test_upload_directory_exclude_patterns', 'test_upload_directory_gitignore_default', 'test_upload_directory_no_gitignore', 'test_write_remote_file', 'test_write_remote_file_failure', 'test_write_system_file_no_sudo', 'test_write_system_file_with_sudo']

# %% pts/tests/test_remote.pct.py 3
import json
from io import BytesIO, StringIO
from unittest.mock import MagicMock, patch, call

from appgarden.remote import (
    read_remote_file, write_remote_file, run_remote_command,
    read_garden_state, write_garden_state,
    read_ports_state, write_ports_state,
    GARDEN_STATE_PATH, PORTS_PATH, PRIVILEGED_HELPER_PATH,
    DEFAULT_APP_ROOT, RemoteContext, make_remote_context,
    run_sudo_command, write_system_file,
    garden_state_path, ports_path, caddy_apps_dir, caddy_tunnels_dir,
    app_dir, source_dir, tunnels_state_path,
    check_privileged_helper,
    privileged_systemctl, privileged_install_unit,
    privileged_remove_unit, privileged_journalctl,
)
from appgarden.config import ServerConfig

# %% pts/tests/test_remote.pct.py 5
def test_read_remote_file():
    """read_remote_file calls host.get_file and returns content."""
    host = MagicMock()
    host.get_file.side_effect = lambda remote_filename, filename_or_io, **kw: (
        filename_or_io.write(b"hello world") or True
    )

    result = read_remote_file(host, "/tmp/test.txt")
    assert result == "hello world"
    host.get_file.assert_called_once()

# %% pts/tests/test_remote.pct.py 6
def test_read_remote_file_failure():
    """read_remote_file raises on failure."""
    import pytest
    host = MagicMock()
    host.get_file.return_value = False

    with pytest.raises(RuntimeError, match="Failed to read"):
        read_remote_file(host, "/tmp/missing.txt")

# %% pts/tests/test_remote.pct.py 7
def test_write_remote_file():
    """write_remote_file calls host.put_file with a BytesIO."""
    host = MagicMock()
    host.put_file.return_value = True

    write_remote_file(host, "/tmp/out.txt", "content")
    host.put_file.assert_called_once()
    # Verify the content was passed via a BytesIO
    args = host.put_file.call_args
    bio = args.kwargs["filename_or_io"]
    assert bio.getvalue() == b"content"

# %% pts/tests/test_remote.pct.py 8
def test_write_remote_file_failure():
    """write_remote_file raises on failure."""
    import pytest
    host = MagicMock()
    host.put_file.return_value = False

    with pytest.raises(RuntimeError, match="Failed to write"):
        write_remote_file(host, "/tmp/out.txt", "content")

# %% pts/tests/test_remote.pct.py 10
def test_run_remote_command():
    """run_remote_command returns stdout as a string."""
    host = MagicMock()
    output_mock = MagicMock()
    output_mock.stdout = "line1\nline2"
    host.run_shell_command.return_value = (True, output_mock)

    result = run_remote_command(host, "ls /tmp")
    assert result == "line1\nline2"

# %% pts/tests/test_remote.pct.py 11
def test_run_remote_command_failure():
    """run_remote_command raises on command failure."""
    import pytest
    host = MagicMock()
    output_mock = MagicMock()
    output_mock.stderr = "error message"
    host.run_shell_command.return_value = (False, output_mock)

    with pytest.raises(RuntimeError, match="Remote command failed"):
        run_remote_command(host, "bad command")

# %% pts/tests/test_remote.pct.py 13
def test_garden_state_roundtrip():
    """read/write garden state serialises JSON correctly."""
    state_data = {"apps": {"myapp": {"name": "myapp", "method": "static"}}}
    written_bytes = None

    host = MagicMock()

    # Capture what write_garden_state sends (BytesIO)
    def mock_put(filename_or_io, remote_filename, **kw):
        nonlocal written_bytes
        written_bytes = filename_or_io.getvalue()
        return True
    host.put_file.side_effect = mock_put

    write_garden_state(host, state_data)
    assert written_bytes is not None
    assert json.loads(written_bytes.decode("utf-8")) == state_data

    # Now mock read to return what was written (bytes into BytesIO)
    def mock_get(remote_filename, filename_or_io, **kw):
        filename_or_io.write(written_bytes)
        return True
    host.get_file.side_effect = mock_get

    loaded = read_garden_state(host)
    assert loaded == state_data

# %% pts/tests/test_remote.pct.py 15
def test_ports_state_roundtrip():
    """read/write ports state serialises JSON correctly."""
    ports_data = {"next_port": 10002, "allocated": {"10000": "app1", "10001": "app2"}}
    written_bytes = None

    host = MagicMock()

    def mock_put(filename_or_io, remote_filename, **kw):
        nonlocal written_bytes
        written_bytes = filename_or_io.getvalue()
        return True
    host.put_file.side_effect = mock_put

    write_ports_state(host, ports_data)
    assert json.loads(written_bytes.decode("utf-8")) == ports_data

    def mock_get(remote_filename, filename_or_io, **kw):
        filename_or_io.write(written_bytes)
        return True
    host.get_file.side_effect = mock_get

    loaded = read_ports_state(host)
    assert loaded == ports_data

# %% pts/tests/test_remote.pct.py 17
def test_remote_context_defaults():
    """RemoteContext has sensible defaults."""
    ctx = RemoteContext()
    assert ctx.app_root == DEFAULT_APP_ROOT
    assert ctx.needs_sudo is False

# %% pts/tests/test_remote.pct.py 18
def test_make_remote_context_root():
    """make_remote_context for root user: no sudo needed."""
    server = ServerConfig(ssh_user="root", ssh_key="~/.ssh/id_rsa", domain="example.com", host="1.2.3.4")
    ctx = make_remote_context(server)
    assert ctx.app_root == DEFAULT_APP_ROOT
    assert ctx.needs_sudo is False

# %% pts/tests/test_remote.pct.py 19
def test_make_remote_context_nonroot():
    """make_remote_context for non-root user: needs sudo."""
    server = ServerConfig(ssh_user="deploy", ssh_key="~/.ssh/id_rsa", domain="example.com", host="1.2.3.4")
    ctx = make_remote_context(server)
    assert ctx.needs_sudo is True

# %% pts/tests/test_remote.pct.py 20
def test_make_remote_context_custom_app_root():
    """make_remote_context respects custom app_root."""
    server = ServerConfig(
        ssh_user="deploy", ssh_key="~/.ssh/id_rsa", domain="example.com",
        host="1.2.3.4", app_root="/opt/myapps",
    )
    ctx = make_remote_context(server)
    assert ctx.app_root == "/opt/myapps"
    assert ctx.needs_sudo is True

# %% pts/tests/test_remote.pct.py 22
def test_path_functions_default():
    """Path functions return default paths when ctx is None."""
    assert garden_state_path() == f"{DEFAULT_APP_ROOT}/garden.json"
    assert ports_path() == f"{DEFAULT_APP_ROOT}/ports.json"
    assert caddy_apps_dir() == f"{DEFAULT_APP_ROOT}/caddy/apps"
    assert caddy_tunnels_dir() == f"{DEFAULT_APP_ROOT}/caddy/tunnels"
    assert app_dir(None, "myapp") == f"{DEFAULT_APP_ROOT}/apps/myapp"
    assert source_dir(None, "myapp") == f"{DEFAULT_APP_ROOT}/apps/myapp/source"
    assert tunnels_state_path() == f"{DEFAULT_APP_ROOT}/tunnels/active.json"

# %% pts/tests/test_remote.pct.py 23
def test_path_functions_custom_root():
    """Path functions use custom app_root from ctx."""
    ctx = RemoteContext(app_root="/opt/garden")
    assert garden_state_path(ctx) == "/opt/garden/garden.json"
    assert ports_path(ctx) == "/opt/garden/ports.json"
    assert caddy_apps_dir(ctx) == "/opt/garden/caddy/apps"
    assert caddy_tunnels_dir(ctx) == "/opt/garden/caddy/tunnels"
    assert app_dir(ctx, "foo") == "/opt/garden/apps/foo"
    assert source_dir(ctx, "foo") == "/opt/garden/apps/foo/source"
    assert tunnels_state_path(ctx) == "/opt/garden/tunnels/active.json"

# %% pts/tests/test_remote.pct.py 25
def test_run_sudo_command_no_sudo():
    """run_sudo_command without sudo does not pass _sudo."""
    host = MagicMock()
    output_mock = MagicMock()
    output_mock.stdout = "ok"
    host.run_shell_command.return_value = (True, output_mock)

    result = run_sudo_command(host, "apt-get update")
    kwargs = host.run_shell_command.call_args.kwargs
    assert kwargs["command"] == "apt-get update"
    assert "_sudo" not in kwargs
    assert result == "ok"

# %% pts/tests/test_remote.pct.py 26
def test_run_sudo_command_with_sudo():
    """run_sudo_command with needs_sudo passes _sudo=True to pyinfra."""
    host = MagicMock()
    output_mock = MagicMock()
    output_mock.stdout = "ok"
    host.run_shell_command.return_value = (True, output_mock)

    ctx = RemoteContext(needs_sudo=True)
    result = run_sudo_command(host, "apt-get update", ctx=ctx)
    kwargs = host.run_shell_command.call_args.kwargs
    assert kwargs["command"] == "apt-get update"
    assert kwargs["_sudo"] is True

# %% pts/tests/test_remote.pct.py 27
def test_run_sudo_command_with_chain():
    """run_sudo_command passes _sudo for && chains too."""
    host = MagicMock()
    output_mock = MagicMock()
    output_mock.stdout = "ok"
    host.run_shell_command.return_value = (True, output_mock)

    ctx = RemoteContext(needs_sudo=True)
    run_sudo_command(host, "apt-get update && apt-get upgrade -y", ctx=ctx)
    kwargs = host.run_shell_command.call_args.kwargs
    assert kwargs["command"] == "apt-get update && apt-get upgrade -y"
    assert kwargs["_sudo"] is True

# %% pts/tests/test_remote.pct.py 28
def test_run_sudo_command_no_ctx():
    """run_sudo_command with ctx=None does not pass _sudo."""
    host = MagicMock()
    output_mock = MagicMock()
    output_mock.stdout = "ok"
    host.run_shell_command.return_value = (True, output_mock)

    run_sudo_command(host, "systemctl reload caddy", ctx=None)
    kwargs = host.run_shell_command.call_args.kwargs
    assert kwargs["command"] == "systemctl reload caddy"
    assert "_sudo" not in kwargs

# %% pts/tests/test_remote.pct.py 30
def test_write_system_file_no_sudo():
    """write_system_file without sudo writes directly via put_file."""
    host = MagicMock()
    host.put_file.return_value = True

    write_system_file(host, "/etc/caddy/Caddyfile", "content")
    host.put_file.assert_called_once()
    kwargs = host.put_file.call_args.kwargs
    assert kwargs["remote_filename"] == "/etc/caddy/Caddyfile"
    assert "_sudo" not in kwargs

# %% pts/tests/test_remote.pct.py 31
def test_write_system_file_with_sudo():
    """write_system_file with sudo passes _sudo=True to put_file."""
    host = MagicMock()
    host.put_file.return_value = True

    ctx = RemoteContext(needs_sudo=True)
    write_system_file(host, "/etc/caddy/Caddyfile", "content", ctx=ctx)

    host.put_file.assert_called_once()
    kwargs = host.put_file.call_args.kwargs
    assert kwargs["remote_filename"] == "/etc/caddy/Caddyfile"
    assert kwargs["_sudo"] is True
    assert kwargs["filename_or_io"].getvalue() == b"content"

# %% pts/tests/test_remote.pct.py 33
def test_garden_state_with_ctx():
    """read/write garden state uses custom path from ctx."""
    ctx = RemoteContext(app_root="/opt/garden")
    host = MagicMock()

    # Write
    host.put_file.return_value = True
    write_garden_state(host, {"apps": {}}, ctx=ctx)
    put_path = host.put_file.call_args.kwargs["remote_filename"]
    assert put_path == "/opt/garden/garden.json"

    # Read
    host.get_file.side_effect = lambda remote_filename, filename_or_io, **kw: (
        filename_or_io.write(b'{"apps": {}}') or True
    )
    state = read_garden_state(host, ctx=ctx)
    get_path = host.get_file.call_args.kwargs["remote_filename"]
    assert get_path == "/opt/garden/garden.json"
    assert state == {"apps": {}}

# %% pts/tests/test_remote.pct.py 35
def test_check_privileged_helper_installed():
    """check_privileged_helper returns True when wrapper exists."""
    host = MagicMock()
    output_mock = MagicMock(); output_mock.stdout = ""
    host.run_shell_command.return_value = (True, output_mock)

    assert check_privileged_helper(host) is True

# %% pts/tests/test_remote.pct.py 36
def test_check_privileged_helper_missing():
    """check_privileged_helper returns False when wrapper missing."""
    host = MagicMock()
    output_mock = MagicMock(); output_mock.stderr = ""
    host.run_shell_command.return_value = (False, output_mock)

    assert check_privileged_helper(host) is False

# %% pts/tests/test_remote.pct.py 38
def test_privileged_systemctl_root_passthrough():
    """For root (needs_sudo=False), privileged_systemctl calls run_sudo_command directly."""
    host = MagicMock()
    output_mock = MagicMock(); output_mock.stdout = "active"
    host.run_shell_command.return_value = (True, output_mock)

    ctx = RemoteContext(needs_sudo=False)
    result = privileged_systemctl(host, "is-active", "appgarden-myapp.service", ctx=ctx)
    assert result == "active"
    cmd = host.run_shell_command.call_args.kwargs["command"]
    assert cmd.startswith("systemctl is-active")
    assert "_sudo" not in host.run_shell_command.call_args.kwargs

# %% pts/tests/test_remote.pct.py 39
def test_privileged_systemctl_root_no_ctx():
    """With ctx=None, privileged_systemctl runs directly without sudo."""
    host = MagicMock()
    output_mock = MagicMock(); output_mock.stdout = "ok"
    host.run_shell_command.return_value = (True, output_mock)

    result = privileged_systemctl(host, "daemon-reload", ctx=None)
    assert result == "ok"
    cmd = host.run_shell_command.call_args.kwargs["command"]
    assert cmd == "systemctl daemon-reload"

# %% pts/tests/test_remote.pct.py 40
def test_privileged_systemctl_nonroot_wrapper():
    """For non-root, privileged_systemctl routes through wrapper."""
    host = MagicMock()
    output_mock = MagicMock(); output_mock.stdout = "active"
    # First call: check wrapper exists (test -x); second call: actual command
    host.run_shell_command.side_effect = [
        (True, MagicMock(stdout="")),   # check_privileged_helper
        (True, output_mock),             # actual systemctl via wrapper
    ]

    ctx = RemoteContext(needs_sudo=True)
    result = privileged_systemctl(host, "restart", "appgarden-myapp.service", ctx=ctx)
    assert result == "active"
    # The second call should use the wrapper path
    cmd = host.run_shell_command.call_args_list[1].kwargs["command"]
    assert PRIVILEGED_HELPER_PATH in cmd
    assert "systemctl restart" in cmd

# %% pts/tests/test_remote.pct.py 41
def test_privileged_systemctl_nonroot_daemon_reload():
    """Non-root daemon-reload routes through wrapper without unit name."""
    host = MagicMock()
    output_mock = MagicMock(); output_mock.stdout = ""
    host.run_shell_command.side_effect = [
        (True, MagicMock(stdout="")),   # check_privileged_helper
        (True, output_mock),
    ]

    ctx = RemoteContext(needs_sudo=True)
    privileged_systemctl(host, "daemon-reload", ctx=ctx)
    cmd = host.run_shell_command.call_args_list[1].kwargs["command"]
    assert "systemctl daemon-reload" in cmd
    assert PRIVILEGED_HELPER_PATH in cmd

# %% pts/tests/test_remote.pct.py 42
def test_privileged_systemctl_nonroot_caddy_reload():
    """Non-root caddy reload routes through wrapper."""
    host = MagicMock()
    output_mock = MagicMock(); output_mock.stdout = ""
    host.run_shell_command.side_effect = [
        (True, MagicMock(stdout="")),
        (True, output_mock),
    ]

    ctx = RemoteContext(needs_sudo=True)
    privileged_systemctl(host, "reload", "caddy", ctx=ctx)
    cmd = host.run_shell_command.call_args_list[1].kwargs["command"]
    assert "systemctl reload caddy" in cmd

# %% pts/tests/test_remote.pct.py 43
def test_privileged_systemctl_nonroot_no_wrapper():
    """Non-root without wrapper raises helpful error."""
    import pytest
    host = MagicMock()
    output_mock = MagicMock(); output_mock.stderr = ""
    host.run_shell_command.return_value = (False, output_mock)

    ctx = RemoteContext(needs_sudo=True)
    with pytest.raises(RuntimeError, match="Re-run.*server init"):
        privileged_systemctl(host, "restart", "appgarden-myapp.service", ctx=ctx)

# %% pts/tests/test_remote.pct.py 45
def test_privileged_install_unit_root():
    """For root, privileged_install_unit writes directly via put_file."""
    host = MagicMock()
    host.put_file.return_value = True

    ctx = RemoteContext(needs_sudo=False)
    privileged_install_unit(host, "appgarden-myapp.service", "[Unit]\nDescription=test", ctx=ctx)
    host.put_file.assert_called_once()
    path = host.put_file.call_args.kwargs["remote_filename"]
    assert path == "/etc/systemd/system/appgarden-myapp.service"

# %% pts/tests/test_remote.pct.py 46
def test_privileged_install_unit_nonroot():
    """For non-root, privileged_install_unit writes temp file then calls wrapper."""
    host = MagicMock()
    host.put_file.return_value = True
    output_mock = MagicMock(); output_mock.stdout = ""
    host.run_shell_command.side_effect = [
        (True, MagicMock(stdout="")),   # check_privileged_helper
        (True, output_mock),             # wrapper call
    ]

    ctx = RemoteContext(needs_sudo=True)
    privileged_install_unit(host, "appgarden-myapp.service", "[Unit]\nDescription=test", ctx=ctx)

    # Temp file written via put_file
    host.put_file.assert_called_once()
    tmp_path = host.put_file.call_args.kwargs["remote_filename"]
    assert tmp_path.startswith("/tmp/appgarden-unit-")

    # Wrapper called with install-unit
    cmd = host.run_shell_command.call_args_list[1].kwargs["command"]
    assert "install-unit" in cmd
    assert PRIVILEGED_HELPER_PATH in cmd

# %% pts/tests/test_remote.pct.py 48
def test_privileged_remove_unit_root():
    """For root, privileged_remove_unit uses rm -f directly."""
    host = MagicMock()
    output_mock = MagicMock(); output_mock.stdout = ""
    host.run_shell_command.return_value = (True, output_mock)

    ctx = RemoteContext(needs_sudo=False)
    privileged_remove_unit(host, "appgarden-myapp.service", ctx=ctx)
    cmd = host.run_shell_command.call_args.kwargs["command"]
    assert "rm -f" in cmd
    assert "appgarden-myapp.service" in cmd

# %% pts/tests/test_remote.pct.py 49
def test_privileged_remove_unit_nonroot():
    """For non-root, privileged_remove_unit routes through wrapper."""
    host = MagicMock()
    output_mock = MagicMock(); output_mock.stdout = ""
    host.run_shell_command.side_effect = [
        (True, MagicMock(stdout="")),   # check_privileged_helper
        (True, output_mock),
    ]

    ctx = RemoteContext(needs_sudo=True)
    privileged_remove_unit(host, "appgarden-myapp.service", ctx=ctx)
    cmd = host.run_shell_command.call_args_list[1].kwargs["command"]
    assert "remove-unit" in cmd
    assert PRIVILEGED_HELPER_PATH in cmd

# %% pts/tests/test_remote.pct.py 51
def test_privileged_journalctl_root():
    """For root, privileged_journalctl runs journalctl directly."""
    host = MagicMock()
    output_mock = MagicMock(); output_mock.stdout = "log line 1\nlog line 2"
    host.run_shell_command.return_value = (True, output_mock)

    ctx = RemoteContext(needs_sudo=False)
    result = privileged_journalctl(host, "appgarden-myapp.service", lines=100, ctx=ctx)
    assert result == "log line 1\nlog line 2"
    cmd = host.run_shell_command.call_args.kwargs["command"]
    assert "journalctl -u" in cmd

# %% pts/tests/test_remote.pct.py 52
def test_privileged_journalctl_nonroot():
    """For non-root, privileged_journalctl routes through wrapper."""
    host = MagicMock()
    output_mock = MagicMock(); output_mock.stdout = "log line"
    host.run_shell_command.side_effect = [
        (True, MagicMock(stdout="")),   # check_privileged_helper
        (True, output_mock),
    ]

    ctx = RemoteContext(needs_sudo=True)
    result = privileged_journalctl(host, "appgarden-myapp.service", lines=25, ctx=ctx)
    assert result == "log line"
    cmd = host.run_shell_command.call_args_list[1].kwargs["command"]
    assert "journalctl" in cmd
    assert "--lines 25" in cmd
    assert PRIVILEGED_HELPER_PATH in cmd

# %% pts/tests/test_remote.pct.py 54
from appgarden.remote import upload_directory
import subprocess as _subprocess

def test_upload_directory_gitignore_default():
    """upload_directory includes --filter ':- .gitignore' by default."""
    server = ServerConfig(ssh_user="root", ssh_key="~/.ssh/id_rsa", domain="example.com", host="1.2.3.4")
    with patch.object(_subprocess, "run") as mock_run:
        upload_directory(server, "/tmp/src", "/srv/appgarden/apps/myapp/source")
    cmd = mock_run.call_args[0][0]
    assert "--filter" in cmd
    idx = cmd.index("--filter")
    assert cmd[idx + 1] == ":- .gitignore"

# %% pts/tests/test_remote.pct.py 55
def test_upload_directory_no_gitignore():
    """upload_directory omits .gitignore filter when gitignore=False."""
    server = ServerConfig(ssh_user="root", ssh_key="~/.ssh/id_rsa", domain="example.com", host="1.2.3.4")
    with patch.object(_subprocess, "run") as mock_run:
        upload_directory(server, "/tmp/src", "/srv/appgarden/apps/myapp/source", gitignore=False)
    cmd = mock_run.call_args[0][0]
    assert "--filter" not in cmd

# %% pts/tests/test_remote.pct.py 56
def test_upload_directory_exclude_patterns():
    """upload_directory adds --exclude flags for each pattern."""
    server = ServerConfig(ssh_user="root", ssh_key="~/.ssh/id_rsa", domain="example.com", host="1.2.3.4")
    with patch.object(_subprocess, "run") as mock_run:
        upload_directory(server, "/tmp/src", "/srv/appgarden/apps/myapp/source",
                         exclude=["node_modules", ".env"], gitignore=False)
    cmd = mock_run.call_args[0][0]
    # Find all --exclude flags
    excludes = []
    for i, arg in enumerate(cmd):
        if arg == "--exclude" and i + 1 < len(cmd):
            excludes.append(cmd[i + 1])
    assert excludes == ["node_modules", ".env"]

# %% pts/tests/test_remote.pct.py 57
def test_upload_directory_exclude_and_gitignore():
    """upload_directory with both gitignore and excludes places filter before excludes."""
    server = ServerConfig(ssh_user="root", ssh_key="~/.ssh/id_rsa", domain="example.com", host="1.2.3.4")
    with patch.object(_subprocess, "run") as mock_run:
        upload_directory(server, "/tmp/src", "/srv/appgarden/apps/myapp/source",
                         exclude=[".venv"], gitignore=True)
    cmd = mock_run.call_args[0][0]
    filter_idx = cmd.index("--filter")
    exclude_idx = cmd.index("--exclude")
    assert filter_idx < exclude_idx, "gitignore filter should come before exclude patterns"
