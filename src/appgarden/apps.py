# AUTOGENERATED! DO NOT EDIT! File to edit: pts/appgarden/06_apps.pct.py

__all__ = ['AppInfo', 'AppStatus', 'app_logs', 'app_status', 'console', 'get_app_metadata', 'list_apps', 'list_apps_with_status', 'redeploy_app', 'remove_app', 'remove_app_metadata_keys', 'restart_app', 'set_app_metadata', 'start_app', 'stop_app', 'update_app_metadata']

# %% pts/appgarden/06_apps.pct.py 3
import shlex
from dataclasses import dataclass

from rich.console import Console

from .config import ServerConfig
from .remote import (
    APPGARDEN_ROOT,
    RemoteContext, make_remote_context,
    ssh_connect, run_remote_command, write_remote_file,
    read_garden_state, write_garden_state, upload_directory,
    privileged_systemctl, privileged_remove_unit, privileged_journalctl,
)
from .routing import parse_url, remove_caddy_config
from .ports import release_port
from .deploy import _app_dir, _source_dir, _systemd_unit_name, _write_env_file, is_git_url, SYSTEMD_UNIT_DIR
from .routing import render_template

console = Console()

# %% pts/appgarden/06_apps.pct.py 5
@dataclass
class AppInfo:
    name: str
    method: str
    url: str
    routing: str
    port: int | None = None
    status: str | None = None
    repo: str | None = None

# %% pts/appgarden/06_apps.pct.py 6
def list_apps(host, ctx: RemoteContext | None = None) -> list[AppInfo]:
    """List all apps from garden.json."""
    state = read_garden_state(host, ctx=ctx)
    apps = []
    for name, entry in state.get("apps", {}).items():
        apps.append(AppInfo(
            name=name,
            method=entry.get("method", "unknown"),
            url=entry.get("url", ""),
            routing=entry.get("routing", ""),
            port=entry.get("port"),
            repo=entry.get("repo"),
        ))
    return apps

# %% pts/appgarden/06_apps.pct.py 7
def list_apps_with_status(host, ctx: RemoteContext | None = None) -> list[AppInfo]:
    """List all apps with live systemd status."""
    apps = list_apps(host, ctx=ctx)
    for app in apps:
        if app.method == "static":
            app.status = "serving"
        else:
            unit = _systemd_unit_name(app.name)
            try:
                result = privileged_systemctl(host, "is-active", unit, ctx=ctx)
                app.status = result.strip()
            except RuntimeError:
                app.status = "inactive"
    return apps

# %% pts/appgarden/06_apps.pct.py 9
@dataclass
class AppStatus:
    name: str
    method: str
    url: str
    routing: str
    port: int | None
    status: str
    source: str | None = None
    source_type: str | None = None
    created_at: str | None = None
    updated_at: str | None = None
    repo: str | None = None
    meta: dict | None = None

# %% pts/appgarden/06_apps.pct.py 10
def app_status(host, name: str, ctx: RemoteContext | None = None) -> AppStatus:
    """Get detailed status for a single app."""
    state = read_garden_state(host, ctx=ctx)
    if name not in state.get("apps", {}):
        raise ValueError(f"App '{name}' not found")

    entry = state["apps"][name]
    method = entry.get("method", "unknown")

    if method == "static":
        status = "serving"
    else:
        unit = _systemd_unit_name(name)
        try:
            result = privileged_systemctl(host, "is-active", unit, ctx=ctx)
            status = result.strip()
        except RuntimeError:
            status = "inactive"

    return AppStatus(
        name=name,
        method=method,
        url=entry.get("url", ""),
        routing=entry.get("routing", ""),
        port=entry.get("port"),
        status=status,
        source=entry.get("source"),
        source_type=entry.get("source_type"),
        created_at=entry.get("created_at"),
        updated_at=entry.get("updated_at"),
        repo=entry.get("repo"),
        meta=entry.get("meta"),
    )

# %% pts/appgarden/06_apps.pct.py 12
def get_app_metadata(host, name: str, ctx: RemoteContext | None = None) -> dict:
    """Read the ``meta`` dict from garden.json for an app."""
    state = read_garden_state(host, ctx=ctx)
    if name not in state.get("apps", {}):
        raise ValueError(f"App '{name}' not found")
    return state["apps"][name].get("meta", {})

# %% pts/appgarden/06_apps.pct.py 13
def set_app_metadata(host, name: str, meta: dict, ctx: RemoteContext | None = None) -> None:
    """Replace the entire ``meta`` dict for an app."""
    state = read_garden_state(host, ctx=ctx)
    if name not in state.get("apps", {}):
        raise ValueError(f"App '{name}' not found")
    state["apps"][name]["meta"] = meta
    write_garden_state(host, state, ctx=ctx)

# %% pts/appgarden/06_apps.pct.py 14
def update_app_metadata(host, name: str, updates: dict, ctx: RemoteContext | None = None) -> None:
    """Merge *updates* into the existing ``meta`` dict for an app."""
    state = read_garden_state(host, ctx=ctx)
    if name not in state.get("apps", {}):
        raise ValueError(f"App '{name}' not found")
    existing = state["apps"][name].get("meta", {})
    existing.update(updates)
    state["apps"][name]["meta"] = existing
    write_garden_state(host, state, ctx=ctx)

# %% pts/appgarden/06_apps.pct.py 15
def remove_app_metadata_keys(host, name: str, keys: list[str], ctx: RemoteContext | None = None) -> None:
    """Delete specific keys from the ``meta`` dict for an app."""
    state = read_garden_state(host, ctx=ctx)
    if name not in state.get("apps", {}):
        raise ValueError(f"App '{name}' not found")
    existing = state["apps"][name].get("meta", {})
    for k in keys:
        existing.pop(k, None)
    state["apps"][name]["meta"] = existing
    write_garden_state(host, state, ctx=ctx)

# %% pts/appgarden/06_apps.pct.py 17
def _update_app_status(host, name: str, status: str, ctx: RemoteContext | None = None) -> None:
    """Update the status field for an app in garden.json."""
    state = read_garden_state(host, ctx=ctx)
    if name in state.get("apps", {}):
        state["apps"][name]["status"] = status
        write_garden_state(host, state, ctx=ctx)

# %% pts/appgarden/06_apps.pct.py 18
def stop_app(host, name: str, ctx: RemoteContext | None = None) -> None:
    """Stop an app's systemd service."""
    unit = _systemd_unit_name(name)
    privileged_systemctl(host, "stop", unit, ctx=ctx)
    _update_app_status(host, name, "inactive", ctx=ctx)

# %% pts/appgarden/06_apps.pct.py 19
def start_app(host, name: str, ctx: RemoteContext | None = None) -> None:
    """Start an app's systemd service."""
    unit = _systemd_unit_name(name)
    privileged_systemctl(host, "start", unit, ctx=ctx)
    _update_app_status(host, name, "active", ctx=ctx)

# %% pts/appgarden/06_apps.pct.py 20
def restart_app(host, name: str, ctx: RemoteContext | None = None) -> None:
    """Restart an app's systemd service."""
    unit = _systemd_unit_name(name)
    privileged_systemctl(host, "restart", unit, ctx=ctx)
    _update_app_status(host, name, "active", ctx=ctx)

# %% pts/appgarden/06_apps.pct.py 22
def app_logs(host, name: str, lines: int = 50, follow: bool = False, ctx: RemoteContext | None = None) -> str:
    """Fetch logs for an app via journalctl.

    When *follow* is True, this would block â€” use for non-interactive
    retrieval only (follow is handled by the CLI via subprocess).
    Returns the log output as a string.
    """
    unit = _systemd_unit_name(name)
    return privileged_journalctl(host, unit, lines=lines, ctx=ctx)

# %% pts/appgarden/06_apps.pct.py 24
def remove_app(host, name: str, keep_data: bool = False, ctx: RemoteContext | None = None) -> None:
    """Remove an app and all its resources from the server."""
    state = read_garden_state(host, ctx=ctx)
    if name not in state.get("apps", {}):
        raise ValueError(f"App '{name}' not found")

    entry = state["apps"][name]
    method = entry.get("method", "unknown")
    url = entry.get("url", "")
    domain, path = parse_url(url)

    # 1. Stop and disable systemd service (if not static)
    if method != "static":
        unit = _systemd_unit_name(name)
        try:
            privileged_systemctl(host, "stop", unit, ctx=ctx)
        except RuntimeError:
            pass
        try:
            privileged_systemctl(host, "disable", unit, ctx=ctx)
        except RuntimeError:
            pass
        # Remove unit file
        privileged_remove_unit(host, unit, ctx=ctx)
        privileged_systemctl(host, "daemon-reload", ctx=ctx)

    # 2. Remove Caddy config
    remove_caddy_config(host, app_name=name, domain=domain, path=path,
                        garden_state=state, ctx=ctx)

    # 3. Release port
    if entry.get("port") is not None:
        try:
            release_port(host, name)
        except ValueError:
            pass

    # 4. Remove from garden.json
    del state["apps"][name]
    write_garden_state(host, state, ctx=ctx)

    # 5. Remove app files
    adir = _app_dir(name, ctx)
    if keep_data:
        # Remove everything except data/
        run_remote_command(host,
            f"find {shlex.quote(adir)} -mindepth 1 -maxdepth 1 ! -name data -exec rm -rf {{}} +")
    else:
        run_remote_command(host, f"rm -rf {shlex.quote(adir)}")

# %% pts/appgarden/06_apps.pct.py 26
def redeploy_app(server: ServerConfig, host, name: str, ctx: RemoteContext | None = None) -> None:
    """Redeploy an app: update source, rebuild, restart."""
    if ctx is None:
        ctx = make_remote_context(server)
    state = read_garden_state(host, ctx=ctx)
    if name not in state.get("apps", {}):
        raise ValueError(f"App '{name}' not found")

    entry = state["apps"][name]
    method = entry.get("method", "unknown")
    source = entry.get("source")
    source_type = entry.get("source_type")
    source_path = _source_dir(name, ctx)

    # 1. Update source
    if source_type == "git":
        console.print("  [dim]Pulling latest changes...[/dim]")
        branch = entry.get("branch")
        if branch:
            run_remote_command(host, f"cd {shlex.quote(source_path)} && git pull origin {shlex.quote(branch)}", timeout=120)
        else:
            run_remote_command(host, f"cd {shlex.quote(source_path)} && git pull", timeout=120)
    elif source_type == "local" and source:
        console.print("  [dim]Re-uploading source...[/dim]")
        exclude = entry.get("exclude")
        gitignore = entry.get("gitignore", True)
        upload_directory(server, source, source_path, exclude=exclude, gitignore=gitignore)

    # 2. Rebuild Docker image and regenerate docker-compose.yml if applicable
    if method in ("dockerfile", "auto"):
        image_name = f"appgarden-{name}"
        console.print("  [dim]Rebuilding Docker image...[/dim]")
        run_remote_command(host, f"docker build -t {shlex.quote(image_name)} {shlex.quote(source_path)}", timeout=600)

        # Regenerate docker-compose.yml with stored settings
        adir = _app_dir(name, ctx)
        port = entry.get("port")
        container_port = entry.get("container_port", 3000)
        volumes = entry.get("volumes")
        try:
            run_remote_command(host, f"test -f {shlex.quote(adir + '/.env')}")
            env_file_flag = ".env"
        except RuntimeError:
            env_file_flag = None
        compose_content = render_template(
            "docker-compose.yml.j2",
            port=port,
            container_port=container_port,
            env_file=env_file_flag,
            volumes=volumes or None,
        )
        compose_content = compose_content.replace(
            "    build: .",
            f"    image: {image_name}",
        )
        write_remote_file(host, f"{adir}/docker-compose.yml", compose_content)

    # 3. Restart service (if not static)
    if method != "static":
        unit = _systemd_unit_name(name)
        console.print("  [dim]Restarting service...[/dim]")
        privileged_systemctl(host, "restart", unit, ctx=ctx)
    else:
        # Static: Caddy serves files directly, just reload
        privileged_systemctl(host, "reload", "caddy", ctx=ctx)

    # 4. Update timestamp and status
    from datetime import datetime, timezone
    entry["updated_at"] = datetime.now(timezone.utc).isoformat()
    entry["status"] = "serving" if method == "static" else "active"
    state["apps"][name] = entry
    write_garden_state(host, state, ctx=ctx)
