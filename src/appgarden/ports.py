# AUTOGENERATED! DO NOT EDIT! File to edit: pts/appgarden/02_ports.pct.py

__all__ = ['PORT_RANGE_START', 'allocate_port', 'empty_ports_state', 'get_app_port', 'register_port', 'release_port']

# %% pts/appgarden/02_ports.pct.py 3
from .remote import (
    read_ports_state, write_ports_state,
    read_ports_state_locked, write_ports_state_locked,
)

# %% pts/appgarden/02_ports.pct.py 5
PORT_RANGE_START = 10000

# %% pts/appgarden/02_ports.pct.py 7
def empty_ports_state() -> dict:
    """Return a fresh, empty ports state."""
    return {"next_port": PORT_RANGE_START, "allocated": {}}

# %% pts/appgarden/02_ports.pct.py 8
def _allocate_port(ports: dict, app_name: str) -> tuple[dict, int]:
    """Allocate the next available port for *app_name*.

    Returns ``(updated_ports, port_number)``.
    If *app_name* already has a port, returns the existing allocation.
    """
    # Return existing port if app already has one
    for port_str, name in ports["allocated"].items():
        if name == app_name:
            return ports, int(port_str)

    port = ports["next_port"]
    ports["allocated"][str(port)] = app_name
    ports["next_port"] = port + 1
    return ports, port

# %% pts/appgarden/02_ports.pct.py 9
def _release_port(ports: dict, app_name: str) -> dict:
    """Release the port held by *app_name*.

    Returns the updated ports dict.
    Raises ``ValueError`` if *app_name* has no allocated port.
    """
    for port_str, name in list(ports["allocated"].items()):
        if name == app_name:
            del ports["allocated"][port_str]
            return ports
    raise ValueError(f"No port allocated for app '{app_name}'")

# %% pts/appgarden/02_ports.pct.py 10
def _register_port(ports: dict, port: int, app_name: str) -> dict:
    """Register a specific *port* for *app_name* (e.g. user-specified port).

    Returns the updated ports dict.
    Raises ``ValueError`` if the port is already in use.
    """
    port_str = str(port)
    if port_str in ports["allocated"]:
        existing = ports["allocated"][port_str]
        raise ValueError(f"Port {port} already allocated to '{existing}'")
    ports["allocated"][port_str] = app_name
    # Advance next_port past this one if needed
    if port >= ports["next_port"]:
        ports["next_port"] = port + 1
    return ports

# %% pts/appgarden/02_ports.pct.py 12
def allocate_port(host, app_name: str) -> int:
    """Allocate a port on the remote server for *app_name*."""
    ports = read_ports_state_locked(host)
    ports, port = _allocate_port(ports, app_name)
    write_ports_state_locked(host, ports)
    return port

# %% pts/appgarden/02_ports.pct.py 13
def release_port(host, app_name: str) -> None:
    """Release the port held by *app_name* on the remote server."""
    ports = read_ports_state_locked(host)
    ports = _release_port(ports, app_name)
    write_ports_state_locked(host, ports)

# %% pts/appgarden/02_ports.pct.py 14
def register_port(host, port: int, app_name: str) -> None:
    """Register a user-specified *port* for *app_name* on the remote server."""
    ports = read_ports_state_locked(host)
    ports = _register_port(ports, port, app_name)
    write_ports_state_locked(host, ports)

# %% pts/appgarden/02_ports.pct.py 15
def get_app_port(host, app_name: str) -> int | None:
    """Return the port allocated to *app_name*, or ``None`` if none."""
    ports = read_ports_state(host)
    for port_str, name in ports["allocated"].items():
        if name == app_name:
            return int(port_str)
    return None
