# AUTOGENERATED! DO NOT EDIT! File to edit: pts/appgarden/09_tunnel.pct.py

__all__ = ['TUNNELS_STATE_FILE', 'TunnelInfo', 'cleanup_stale_tunnels', 'close_tunnel', 'console', 'list_tunnels', 'open_tunnel']

# %% pts/appgarden/09_tunnel.pct.py 3
import json
import signal
import subprocess
import sys
import uuid
from dataclasses import dataclass
from datetime import datetime, timezone

from rich.console import Console

from .config import ServerConfig, resolve_host
from .remote import (
    ssh_connect, run_remote_command, read_remote_file, write_remote_file,
    APPGARDEN_ROOT,
)
from .ports import allocate_port, release_port
from .routing import generate_caddy_config, CADDY_TUNNELS_DIR

console = Console()

# %% pts/appgarden/09_tunnel.pct.py 5
TUNNELS_STATE_FILE = f"{APPGARDEN_ROOT}/tunnels/active.json"

# %% pts/appgarden/09_tunnel.pct.py 7
@dataclass
class TunnelInfo:
    tunnel_id: str
    url: str
    local_port: int
    remote_port: int
    created_at: str

# %% pts/appgarden/09_tunnel.pct.py 9
def _read_tunnels_state(host) -> dict:
    """Read the active tunnels state from the server."""
    try:
        content = read_remote_file(host, TUNNELS_STATE_FILE)
        return json.loads(content)
    except (RuntimeError, json.JSONDecodeError):
        return {"tunnels": {}}

# %% pts/appgarden/09_tunnel.pct.py 10
def _write_tunnels_state(host, state: dict) -> None:
    """Write the active tunnels state to the server."""
    write_remote_file(host, TUNNELS_STATE_FILE, json.dumps(state, indent=2))

# %% pts/appgarden/09_tunnel.pct.py 12
def _tunnel_caddy_path(tunnel_id: str) -> str:
    """Path for a tunnel's Caddy config file."""
    return f"{CADDY_TUNNELS_DIR}/{tunnel_id}.caddy"

# %% pts/appgarden/09_tunnel.pct.py 13
def _deploy_tunnel_caddy(host, tunnel_id: str, domain: str, remote_port: int) -> None:
    """Deploy a temporary Caddy config for the tunnel."""
    config = generate_caddy_config(
        domain=domain,
        port=remote_port,
    )
    caddy_path = _tunnel_caddy_path(tunnel_id)
    write_remote_file(host, caddy_path, config)
    run_remote_command(host, "systemctl reload caddy")

# %% pts/appgarden/09_tunnel.pct.py 14
def _remove_tunnel_caddy(host, tunnel_id: str) -> None:
    """Remove a tunnel's Caddy config and reload."""
    caddy_path = _tunnel_caddy_path(tunnel_id)
    try:
        run_remote_command(host, f"rm -f {caddy_path}")
        run_remote_command(host, "systemctl reload caddy")
    except RuntimeError:
        pass

# %% pts/appgarden/09_tunnel.pct.py 15
def _register_tunnel(host, tunnel_id: str, url: str, local_port: int, remote_port: int) -> None:
    """Record the tunnel in active.json."""
    state = _read_tunnels_state(host)
    state["tunnels"][tunnel_id] = {
        "url": url,
        "local_port": local_port,
        "remote_port": remote_port,
        "created_at": datetime.now(timezone.utc).isoformat(),
    }
    _write_tunnels_state(host, state)

# %% pts/appgarden/09_tunnel.pct.py 16
def _unregister_tunnel(host, tunnel_id: str) -> None:
    """Remove the tunnel from active.json."""
    state = _read_tunnels_state(host)
    state["tunnels"].pop(tunnel_id, None)
    _write_tunnels_state(host, state)

# %% pts/appgarden/09_tunnel.pct.py 18
def _cleanup_tunnel(server: ServerConfig, tunnel_id: str, app_name: str) -> None:
    """Full cleanup: remove Caddy config, release port, unregister."""
    with ssh_connect(server) as host:
        _remove_tunnel_caddy(host, tunnel_id)
        try:
            release_port(host, app_name)
        except ValueError:
            pass
        _unregister_tunnel(host, tunnel_id)

# %% pts/appgarden/09_tunnel.pct.py 20
def open_tunnel(server: ServerConfig, local_port: int, url: str) -> None:
    """Open a tunnel: allocate port, configure Caddy, SSH reverse tunnel.

    Blocks until Ctrl+C, then cleans up.
    """
    tunnel_id = f"tunnel-{uuid.uuid4().hex[:8]}"
    app_name = tunnel_id
    host_ip = resolve_host(server)

    # 1. Allocate port and set up Caddy
    with ssh_connect(server) as host:
        remote_port = allocate_port(host, app_name)
        _deploy_tunnel_caddy(host, tunnel_id, url, remote_port)
        _register_tunnel(host, tunnel_id, url, local_port, remote_port)

    console.print(f"[green]Tunnel open:[/green] https://{url} -> localhost:{local_port}")
    console.print(f"[dim]Remote port: {remote_port} | Tunnel ID: {tunnel_id}[/dim]")
    console.print("[dim]Press Ctrl+C to close the tunnel.[/dim]")

    # 2. Open SSH reverse tunnel
    ssh_cmd = [
        "ssh", "-N",
        "-R", f"{remote_port}:localhost:{local_port}",
        "-i", server.ssh_key,
        "-o", "StrictHostKeyChecking=no",
        "-o", "ServerAliveInterval=30",
        "-o", "ServerAliveCountMax=3",
        f"{server.ssh_user}@{host_ip}",
    ]

    proc = None
    try:
        proc = subprocess.Popen(ssh_cmd)
        proc.wait()
    except KeyboardInterrupt:
        console.print("\n[yellow]Closing tunnel...[/yellow]")
    finally:
        if proc and proc.poll() is None:
            proc.terminate()
            proc.wait(timeout=5)
        _cleanup_tunnel(server, tunnel_id, app_name)
        console.print("[green]Tunnel closed.[/green]")

# %% pts/appgarden/09_tunnel.pct.py 22
def close_tunnel(server: ServerConfig, tunnel_id: str) -> None:
    """Close a specific tunnel by ID (remote cleanup only)."""
    app_name = tunnel_id
    _cleanup_tunnel(server, tunnel_id, app_name)

# %% pts/appgarden/09_tunnel.pct.py 24
def list_tunnels(host) -> list[TunnelInfo]:
    """List all active tunnels from the server."""
    state = _read_tunnels_state(host)
    tunnels = []
    for tid, data in state.get("tunnels", {}).items():
        tunnels.append(TunnelInfo(
            tunnel_id=tid,
            url=data.get("url", ""),
            local_port=data.get("local_port", 0),
            remote_port=data.get("remote_port", 0),
            created_at=data.get("created_at", ""),
        ))
    return tunnels

# %% pts/appgarden/09_tunnel.pct.py 26
def cleanup_stale_tunnels(server: ServerConfig) -> list[str]:
    """Detect and remove tunnels whose SSH connections are dead.

    Returns list of cleaned-up tunnel IDs.
    """
    cleaned = []
    with ssh_connect(server) as host:
        state = _read_tunnels_state(host)
        for tid, data in list(state.get("tunnels", {}).items()):
            remote_port = data.get("remote_port")
            if remote_port is None:
                continue
            # Check if anything is listening on the remote port
            try:
                result = run_remote_command(
                    host, f"ss -tln | grep -q ':{remote_port} ' && echo active || echo inactive"
                )
                if "inactive" in result:
                    close_tunnel(server, tid)
                    cleaned.append(tid)
            except RuntimeError:
                close_tunnel(server, tid)
                cleaned.append(tid)
    return cleaned
